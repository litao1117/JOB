# Webpack 和 Vite 对比

## 开发语言
vite基于esbuild构建依赖，底层使用go语言开发，要比js打包器速度快很多。
## 启动
* webpack：分析依赖=》编译打包 =》交给本地服务器进行渲染。 首先分析各个模块间的依赖，然后进行打包，启动webpack-dev-server，请求服务器时直接显示打包结果。随着模块的增多，打包后的bundle体积过大，会造成热更新速度明显减慢。
* vite：启动服务器=》 请求模块时按需动态编译展示。 是先启动开发服务器，请求某个模块时再对该模块进行实时编译，现代浏览器本身支持ES-module，所以会自动向依赖的module发出请求。

`vite相关生态没有webpack完善`

# Webpack构建流程
1. 初始化参数，从配置文件读取和 shell参数 进行合并，得到最终参数
2. 开始编译，用得到的参数初始化编译器对象，加载所有配置的插件，开始执行编译。
3. 找到入口
4. 编译模块：从入口文件出发，调用所有配置的loader对模块进行编译，在找到该模块所依赖的模块，递归该过程直到所有依赖文件都经过编译。
5. 完成模块编译，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。
6. 输出资源，根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再把每个chunk转换成一个单独的文件加入的输出列表，这是可以修改输出内容的最后机会。
7. 输出完成，根据配置的输出路径和文件名，将文件内容写入文件系统。

# webpack 热更新原理
webpack热更新可以做到不用刷新浏览器而将变更的模块替换掉旧的模块。
HMR的核心就是客户端从服务端拉取更新后的文件，准确来说是chunk diff，webpack-dev-server 与浏览器之间维护了一个websocket连接，当本地资源发生变化时，wds会像浏览器推送更新，并带上构建时的hash，让客户端与上一次资源进行对比，对比差异后会像wds发ajax请求获取更改内容(文件列表，hash)，这样客户端就借助这些信息继续向wds发起jsonp请求获取增量更新。

# 编写plugin
1. 具名js函数
2. 函数prototype上定义一个apply方法。
3. 指定一个绑定到webpack自身的事件钩子。
4. 处理数据
5. 调用webpack提供的callback。

# 编写loader
合理利用loader-utils
1. 获取文件内容
2. 对资源进行转换
3. 返回转换后的内容，同步可通过this.callback()，this.async()异步

# webpack5新特性
1. 开启生产模式，自动压缩代码
2. 持久化缓存
3. 优化tree-shaking
4. MF