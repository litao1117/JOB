# 进程与线程
## 1.定义
**进程**是资源（CPU、内存等）分配的基本单位，具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。 
**线程**是进程的一个实体，是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。
线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。

## 2.区别
1. 进程是资源分配的基本单位；线程是程序执行的基本单位。
2. 进程拥有自己的资源空间，没启动一个进程，系统就会为它分配地址空间；而线程与CPU资源分配无关，多个线程共享同一进程内的资源，使用相同的地址空间。
3. 一个进程可以包含若干个线程。

## 3.优劣
1. 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（Inter Process Communication，IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
2. 线程的调度与切换比进程快很多，同时创建一个线程的开销也比进程要小很多。
3. 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。


## 4.进程间如何通信
### 1.管道

```
netstat -tulnp | grep 8080
```

这是一条普通的linux语句，其中`|`就是管道的意思，它的作用就是将前一条命令的输出作为后一条命令的输入。ES新提案也有了管道运算符。

如果两个进程之间需要通信就可以用这种方式进行通信。

管道的通知机制类似于缓存，一个进程把数据存放在某个缓存区域，然后等着另一个进程去拿，并且管道是单向传输的。进程之间想要互相通信的话，就需要创建两个管道了。

#### 优劣

* 这个通信方式显然的缺点就是效率低下，a进程给b进程传输数据，a进程只能等待b进程取了数据之后才能返回。所以这种通信方式并不适用于频繁通信的进程。

* 优点即比较简单，能确保我们的数据真的被其他进程拿走了。

### 2.消息队列

消息队列是在两个不相关进程之间传递数据的一种简单、高效的方式。

消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为是一个管道，接收进程可以独立的接收含有不同管道的数据结构。我们可以将每个数据块当做是一种消息类型（频道），发送和接收的内容就是这个类型（频道）对应的消息（节目），每个类型（频道）相当于一个独立的管道，相互之间不受影响。

#### 缺点

* 当发送的数据占的内存较大，意味着接收进程需要拷贝的时间也就越多。

### 3.共享内存

每个进程都有自己的虚拟内存空间，不同的进程映射到不同的物理内存空间。

共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射到自身的地址空间中，一个进程写入共享内存的消息，可以被其他共享这个存储区的进程读出，从而实现的进程间通信。

#### 优劣

* 效率较高，因为进程可以直接读写内存，不需要进行任何数据的拷贝
* 多进程共享内存，如果同时都往里写内容，有可能会出现冲突的现象。

### 4.信号量

为了防止冲突，使得同一份共享的资源只能一个进程使用，就出现了信号量机制。

信号量实际上是一个计数器，信号量主要实现进程之间的同步和互斥，而不是存储通信内容。

信号量定义了两种操作，pv操作，p操作为申请资源，将数值减去M，表示这部分资源被它占用了，其他进程暂时不能使用。v操作是归还操作，告知归还了资源，可以使用这部分。

### 5.信号

我们或许听说过运维或者部分开发需要7 * 24小时值守(项目需要上线的时候)，当然也有各种监管，告警系统，一旦出现系统资源紧张等问题就会告知开发或运维人员，对应到操作系统中，这就是信号。

在操作系统中，不同信号用不同的值表示，每个信号设置相应的函数，一旦进程发送某一个信号给另一个进程，另一进程将执行相应的函数进行处理。也就是说先把可能出现的异常等问题准备好，一旦信号产生就执行相应的逻辑即可。

# 死锁

## 1.概念

在许多应用中进程需要以**独占**的方式访问资源，当操作系统运行多进程并发执行时可能会出现进程永远被阻塞现象。如两个进程分别等待对方所占的资源，于是两者都不能执行**永远处于等待状态**，此现象称为**死锁**

## 2.产生条件

* 互斥条件

  临界资源是独占资源，进程应互斥且排他的使用这些资源

* 占有和等待条件

  进程在请求资源而得不到满足处于等待状态时，不释放已占用资源

* 不剥夺条件

  又称“不可抢占”，进程已获资源只能由进程主动释放，不能被其他进程剥夺

* 循环等待条件

  又称“环路等待”，存在循环等待链，其中，每个进程都在等待链中等待下一个进程所持有的资源，造成这组进程**永远处于等待状态**

**死锁只有在这四个条件同时满足时出现**

## 3.产生原因

死锁产生的原因有很多：

* 系统资源不足
* 进程运行推进顺序不当
* 同类资源分配不均
* 对某些资源使用未加限制

等等。

> 如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则
> 就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。

## 4.死锁的解决办法

* 死锁防止

  至少破坏四个条件其中一个

  1. 使资源能同时访问而不是互斥访问，破坏互斥条件。
  2. 采用静态分配的方式，进程在执行之前必须申请需要的全部资源，等全部资源都得到满足之后才开始执行，破坏占有和等待条件。
  3. 资源分配管理程序为进程分配新资源时，若有则分配；否则将剥夺此进程已占有的全部资源，并让进程进入等待资源状态，资源充足后再唤醒它重新申请所有所需资源。
  4. 给系统的所有资源编号，规定进程请求所需资源的顺序必须按照资源的编号依次进行。

* 死锁避免

  > 各种死锁防止方法能够防止发生死锁，但会降低系统并发性，降低资源利用率。

  **安全状态**：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。

  **银行家算法**：判断对进程资源请求满足之后是否会进入不安全状态，如果是就拒绝请求，否则分配资源。

* 死锁检测和恢复

  不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

  死锁检测算法：通过检测进程-资源分配图中是否存在环，从一个出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

  死锁恢复：资源剥夺、进程回退、进程撤销、重启

# 浏览器进程

浏览器已经从单进程浏览器阶段进化到多进程浏览器阶段，那么多进程指的是哪些进程呢？

## 1.浏览器主进程

打开浏览器后只有一个，主要负责界面显示、用户交互、子进程关闭，除此之外，还会提供存储等功能。

## 2.渲染进程

其主要作用是页面渲染、脚本执行、事件处理等，默认情况下，Chrome会为每个Tab标签创建一个渲染进程（注意：出于安全考虑，渲染进程都运行在沙箱模式下）。对于渲染进程其是由多线程组成，多线程包含以下几个：

> 沙箱：一种安全机制，为执行中的程式提供一个完全隔离的环境，以避免对使用的作业系统造成危害。沙盒通常会严格限制程式所能存取的资源，包括磁盘及内存空间。当然这也属于虚拟化的一种方法，就如同透过虚拟机器建立电脑一样。

### （1）GUI渲染线程

主要负责渲染浏览器界面，解析HTML、CSS、构建DOM树和渲染树，布局和绘制等。当界面需要重绘或回流时，该线程就会执行。

### （2）JS引擎线程

主要负责解析并执行JS代码

**注意：**JS引擎线程和GUI渲染线程是互斥关系，当JS引擎线程执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即执行，所以JS执行的时间过程，就会造成页面渲染不连贯，导致页面渲染加载阻塞。

### （3）事件触发线程

用来控制事件循环，当js引擎执行代码时，会将对应的任务（例如Ajax任务、鼠标点击......等）添加到事件线程中，当线程被触发时，事件线程会把事件添加到待处理事件队列的队尾，等待js引擎的处理。

### （4）定时触发器线程

setInterval和setTimeout所在的线程，浏览器定时计数器并不是js引擎计数的，通过单独的线程来计时并触发定时。

### （5）异步http请求线程

用于处理请求XMLHttpRequest，在连接后是通过浏览器新开一个线程请求。

## 3.GPU进程

GPU进程只有一个。GPU使用初衷是为了实现3D CSS的效果，随着网页、Chrome的UI界面都选择采用GPU来绘制，使得GPU成为浏览器的普遍需求，最后，Chrome在其多进程架构上也引入了GPU进程。

## 4.网络进程

只有一个，主要负责页面的网络资源加载

## 5.插件进程

每个类型的插件对应着一个进程，主要负责插件的运行。因为插件易奔溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

